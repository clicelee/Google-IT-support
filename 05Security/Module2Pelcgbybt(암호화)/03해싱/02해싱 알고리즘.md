### 해싱 함수 개요

- **MD5**:
  - 1990년대 초에 설계된 해시 함수로, 512비트 블록에서 작동하며 128비트 해시 다이제스트를 생성함.
  - 1996년에 디자인 결함이 발견되었으나 심각하지 않다고 여겨졌음.
  - 2004년에 해시 충돌 취약성이 발견되어 악성 파일이 합법적인 파일과 동일한 MD5 다이제스트를 생성할 수 있음.
  - 2010년까지 암호화 애플리케이션에서 MD5 사용을 중단하도록 권장됨.
  - 2012년에 플레임 멀웨어에서 MD5 해시 충돌이 악용됨.

- **SHA-1**:
  - NSA에 의해 설계된 해시 함수로 1995년에 공개됨.
  - 512비트 블록에서 작동하며 160비트 해시 다이제스트를 생성함.
  - 광범위한 프로토콜과 시스템에서 사용되었으나, 2010년에 SHA-2로 대체할 것을 권장함.
  - 2017년에 SHA-1의 첫 번째 전체 충돌이 공개됨.
  - SHA-1은 Git과 같은 버전 제어 시스템에서도 사용됨.

- **MIC (메시지 무결성 검사)**:
  - 메시지의 해시 다이제스트로, 메시지의 체크섬과 유사함.
  - 비밀 키를 사용하지 않으며, 조작이나 악의적인 행위로부터 보호하지는 않음.
  - 실수에 의한 손상이나 손실로부터 보호하는 역할을 함.

### 해시 함수의 인증 활용

- **비밀번호 해시**:
  - 인증 시스템은 비밀번호 자체가 아닌 비밀번호 해시를 저장해야 함.
  - 로그인 시 입력된 비밀번호를 해싱하여 저장된 해시와 비교함.
  - 비밀번호를 일반 텍스트로 저장하면 안 됨.
  - 비밀번호 해시 데이터베이스에 대해 무차별 대입 공격이 수행될 수 있음.

### 무차별 대입 공격 방어

- **계산 기준 높이기**:
  - 해싱 함수를 여러 번 실행하여 비밀번호 추측 시도에 많은 계산이 필요하게 만듦.
  
- **레인보우 테이블**:
  - 가능한 모든 비밀번호 값과 해당 해시의 미리 계산된 테이블을 사용하여 해시에서 비밀번호를 복구하는 방법.
  - 많은 저장공간이 요구되며, 계산 리소스의 필요성이 줄어듦.

- **솔트 사용**:
  - 비밀번호와 솔트를 조합하여 해시를 생성하고 해시와 솔트를 함께 저장함.
  - 큰 솔트를 사용하면 유용한 레인보우 테이블을 생성하기 위한 계산 및 저장용량 요구사항이 거의 실현 불가능함.
  - 초기 Unix 시스템은 12비트 솔트를 사용했고, 최신 시스템은 128비트 솔트를 사용함.

### 해싱 함수 강의 요약

- **해시 함수의 중요성**:
  - 해싱은 인증, 메시지 무결성, 디지털 서명 등 다양한 용도로 사용됨.
  - 해시 함수는 단방향성, 결정성, 계산 효율성, 충돌 회피 등의 특성을 가져야 함.
  - 해시 함수의 취약점을 이해하고 방어 방법을 아는 것이 중요함.

다음 시간에는 암호화의 실제 사용 사례를 살펴보고 암호화가 다양한 애플리케이션과 프로토콜에서 어떻게 사용되는지 알아볼 것임. 그 전에 먼저 해싱 실습 프로젝트를 완료해야 함.